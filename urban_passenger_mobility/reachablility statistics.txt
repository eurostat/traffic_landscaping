Create Grid:

bounding_box <- st_bbox(city_shape_file) 

grid <- expand.grid(seq(bounding_box[1], bounding_box[3], by = grid_size),
                    seq(bounding_box[2], bounding_box[4], by = grid_size)) %>%
  as_tibble() %>%
  mutate(id = 1:n()) %>%
  relocate(id) %>%
  setNames(c("id", "lon","lat")) %>%
  st_as_sf(coords = c("lon", "lat")) %>%
  st_set_crs(st_crs("+proj=longlat")) %>%
  mutate(point_in = as.numeric(st_intersects(., city_shape_file))) %>%
  filter(!is.na(point_in))%>%
  dplyr::mutate(lon = sf::st_coordinates(.)[,1],
                lat = sf::st_coordinates(.)[,2])


ggplot()+
  geom_sf(data = city_shape_file, fill = "red", alpha = .5) +
  geom_sf(data = grid, fill = "white", col = "white", size = .2, alpha = .5)+
  theme_void() +
  theme(plot.background = element_rect(fill = "black", colour = "black"),
        title = element_text(hjust=1, colour="white", size = 8),
        axis.title.x = element_blank())



Percentage of population reached:

total_pop <-  sum(as.matrix(terra::mask(population_data_city, vect(city_shape_file))),  na.rm = TRUE)
total_pop



Population reached for a given isochrone

get_percentage_function <- function(y,
                                    data = complete_isochone,
                                    cur_total_pop = total_pop,
                                    cur_population_data_city = population_data_city){
  
  cur_isochone <-  data %>% slice(y)
  percent_population_reached <- sum(as.matrix(terra::mask(cur_population_data_city, vect(cur_isochone)) ), 
                                    na.rm = TRUE) / cur_total_pop
  
  area <- st_area(cur_isochone)
  output <- tibble(percent_population_reached = percent_population_reached,
                   time = cur_isochone$time,
                   area = area)
  output
}



24 isochrones for all points and compute for all these isochrones what percentage of the population is reached:

# create empty list to store results
list_results <- list()

# loop over rows in grid
for (i in 1:nrow(grid)) {
  tryCatch({
    
#only look at one point at a time
    test_point <- grid %>%
      slice(i)
    
# select current point data    
    id <- test_point$id
    
    cur_lon <- test_point$lon
    cur_lat <- test_point$lat
    
# compute 24 isochrones per point
    complete_isochone <- otp_isochrone(
      otpcon = otpcon,
      fromPlace = c(cur_lon, cur_lat),
      mode = c("WALK", "TRANSIT"),
      maxWalkDistance = max_walking_distance,
      date_time = date_and_time,
      cutoffSec = seq(5, 120, 5) * 60
    )
    
# use the custom get_percentage_function function 
# to estimate which percentage of the FUA can be
# reached and bind all the results
    output2 <-
      data.table::rbindlist(
        lapply(1:nrow(complete_isochone), 
               FUN = get_percentage_function)
        ) %>%
      as_tibble() %>%
      mutate(id = id,
             cur_lon,
             cur_lat)
    
# store the results in a list
    list_results[[i]] <- output2
    print(paste0(i, " of ", nrow(grid)))
  },
  error = function(e) {
    cat("ERROR :", conditionMessage(e), "\n")
  })
}


# save a ll the results
population_reached_data <- data.table::rbindlist(list_results)%>% 
  as_tibble()

write_csv(population_reached_data,output_population_reached)


population_reached_data <- read_csv(output_population_reached)

population_reached_data %>% 
  arrange(id, time) %>% 
  mutate(percent_population_reached = round(percent_population_reached *100,2)) %>% 
  head(30) %>% 
  kableExtra::kable() %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))




How much of the population can be reached on average

my_vor <- st_as_sf(terra::voronoi(terra::vect(grid))) %>% 
  st_intersection(city_shape_file)


population_data_city_brick <- raster::brick(population_data_city)
my_vor$pop <- as.numeric(extract(population_data_city_brick,my_vor,fun=sum, na.rm =TRUE))

mapview::mapview(my_vor, 
                 alpha.regions = 0.5, 
                 zcol = "pop", 
                 layer.name = "sum population per cell") +
  mapview::mapview(grid,  
                   col.regions ="black",
                   cex = 1,
                   layer.name = "grid points",
                   alpha.regions = 1)



The mean, the median and the weighted mean for each time:

population_reached_data_pop <- population_reached_data %>% 
  left_join(my_vor %>% 
              select(id, pop) %>% 
              st_drop_geometry(),
             by = "id") 

pop_reached_summaries <- population_reached_data_pop%>% 
  group_by(time  ) %>% 
  summarise(mean = mean(percent_population_reached),
            median = median(percent_population_reached),
            weighted_mean = weighted.mean(percent_population_reached, w = pop)) %>% 
  pivot_longer(cols = -c(time))


ggplot() +
  geom_line(data =population_reached_data_pop, 
            aes(x = time/60, y = percent_population_reached, group = id ), 
            alpha =.1) +
  geom_line(data = pop_reached_summaries, 
            aes(x = time/60, y = value, col = name ),
            inherit.aes = FALSE,
            alpha = .9,
            size = 3) +
  ggthemes::scale_color_tableau() +
  theme_minimal()+
  scale_y_continuous(labels = scales::percent)+
  labs(y = "percent population reached",
       x = "travel time in minutes",
       col = NULL) +
  theme(legend.position = "bottom")



Table format: 

 pop_reached_summaries %>% 
    mutate(value = paste0(format(round(value*100, 2), nsmall = 1), "%")) %>% 
    pivot_wider(names_from = name, values_from = value) %>% 
    mutate(time = time/60) %>% 
    mutate(time = sub(":\\d{2}", "", chron::times((time%/%60 +  time%%60 /3600)/24))) %>% 
    kableExtra::kable() %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))



Splitting the plot into 9 facets:

# to make the labels more human readable we can use this function
# taken from https://stackoverflow.com/questions/28159936/format-numbers-with-million-m-and-billion-b-suffixes
format_bignum <- function(n) {
  dplyr::case_when(
    n >= 1e12 ~ paste0(round(n / 1e12, 1), 'Tn'),
    n >= 1e9 ~ paste0(round(n / 1e9, 1), 'Bn'),
    n >= 1e6 ~ paste0(round(n / 1e6, 1), 'M'), 
    n >= 1e3 ~ paste0(round(n / 1e3, 1), 'K'),
    TRUE ~ as.character(round(n, 0))
  )
}



# taken from https://stackoverflow.com/questions/32356108/output-a-numeric-value-from-cut-in-r
cut_borders <- function(x){
  pattern <- "(\\(|\\[)(-*[0-9]+\\.*[0-9]*),(-*[0-9]+\\.*[0-9]*)(\\)|\\])"
  start <- as.numeric(gsub(pattern,"\\2", x))
  end <- as.numeric(gsub(pattern,"\\3", x))
  data.frame(start, end)
}


population_reached_data_pop2 <- population_reached_data %>% 
  left_join(my_vor %>% select(id, pop) %>% st_drop_geometry()) %>% 
  mutate(qn = cut_number(pop, 9,           
                         ordered_result = T,
                         dig.lab = 50)) %>% 
  mutate(start = cut_borders(qn)[, 1],
         end = cut_borders(qn)[, 2]) %>%
  mutate(end = format_bignum(end),
         start = format_bignum(start)) %>%
  mutate(my_label = paste0(
    stri_sub(
      as.character(qn),
      from = 1,
      to = 1
    ),
    start,
    ",",
    end,
    stri_sub(
      as.character(qn),
      from = -1,
      to = -1
    )
  ))


pop_reached_summaries2 <- population_reached_data_pop2 %>% 
  group_by(time, qn, my_label  ) %>% 
  summarise(mean = mean(percent_population_reached),
            median = median(percent_population_reached),
            weighted_mean = weighted.mean(percent_population_reached, w = pop)) %>% 
  ungroup() %>% 
  pivot_longer(cols = -c(time, qn, my_label))


ggplot() +
  geom_line(data =population_reached_data_pop2%>%
              mutate(my_label =reorder(my_label, as.numeric(qn)) ),
            aes(x = time/60, y = percent_population_reached, group = id ),
            alpha =.1) +
  geom_line(data = pop_reached_summaries2 %>% 
              mutate(my_label =reorder(my_label, as.numeric(qn)) ), 
            aes(x = time/60, y = value, color = name ),
            size = 2) +
  facet_wrap(~my_label) +
 ggthemes::scale_color_tableau() +
 theme_minimal()+
 scale_y_continuous(labels = scales::percent)+
 labs(y = "percent population reached",
     x = "travel time in minutes") +
 theme(legend.position = "bottom")
